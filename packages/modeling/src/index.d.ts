export const colors: {
    colorize: (color: any[], ...objects: any) => any;
    colorNameToRgb: (s: string) => any[];
    cssColors: {
        black: number[];
        silver: number[];
        gray: number[];
        white: number[];
        maroon: number[];
        red: number[];
        purple: number[];
        fuchsia: number[];
        green: number[];
        lime: number[];
        olive: number[];
        yellow: number[];
        navy: number[];
        blue: number[];
        teal: number[];
        aqua: number[];
        aliceblue: number[];
        antiquewhite: number[];
        aquamarine: number[];
        azure: number[];
        beige: number[];
        bisque: number[];
        blanchedalmond: number[];
        blueviolet: number[];
        brown: number[];
        burlywood: number[];
        cadetblue: number[];
        chartreuse: number[];
        chocolate: number[];
        coral: number[];
        cornflowerblue: number[];
        cornsilk: number[];
        crimson: number[];
        cyan: number[];
        darkblue: number[];
        darkcyan: number[];
        darkgoldenrod: number[];
        darkgray: number[];
        darkgreen: number[];
        darkgrey: number[];
        darkkhaki: number[];
        darkmagenta: number[];
        darkolivegreen: number[];
        darkorange: number[];
        darkorchid: number[];
        darkred: number[];
        darksalmon: number[];
        darkseagreen: number[];
        darkslateblue: number[];
        darkslategray: number[];
        darkslategrey: number[];
        darkturquoise: number[];
        darkviolet: number[];
        deeppink: number[];
        deepskyblue: number[];
        dimgray: number[];
        dimgrey: number[];
        dodgerblue: number[];
        firebrick: number[];
        floralwhite: number[];
        forestgreen: number[];
        gainsboro: number[];
        ghostwhite: number[];
        gold: number[];
        goldenrod: number[];
        greenyellow: number[];
        grey: number[];
        honeydew: number[];
        hotpink: number[];
        indianred: number[];
        indigo: number[];
        ivory: number[];
        khaki: number[];
        lavender: number[];
        lavenderblush: number[];
        lawngreen: number[];
        lemonchiffon: number[];
        lightblue: number[];
        lightcoral: number[];
        lightcyan: number[];
        lightgoldenrodyellow: number[];
        lightgray: number[];
        lightgreen: number[];
        lightgrey: number[];
        lightpink: number[];
        lightsalmon: number[];
        lightseagreen: number[];
        lightskyblue: number[];
        lightslategray: number[];
        lightslategrey: number[];
        lightsteelblue: number[];
        lightyellow: number[];
        limegreen: number[];
        linen: number[];
        magenta: number[];
        mediumaquamarine: number[];
        mediumblue: number[];
        mediumorchid: number[];
        mediumpurple: number[];
        mediumseagreen: number[];
        mediumslateblue: number[];
        mediumspringgreen: number[];
        mediumturquoise: number[];
        mediumvioletred: number[];
        midnightblue: number[];
        mintcream: number[];
        mistyrose: number[];
        moccasin: number[];
        navajowhite: number[];
        oldlace: number[];
        olivedrab: number[];
        orange: number[];
        orangered: number[];
        orchid: number[];
        palegoldenrod: number[];
        palegreen: number[];
        paleturquoise: number[];
        palevioletred: number[];
        papayawhip: number[];
        peachpuff: number[];
        peru: number[];
        pink: number[];
        plum: number[];
        powderblue: number[];
        rosybrown: number[];
        royalblue: number[];
        saddlebrown: number[];
        salmon: number[];
        sandybrown: number[];
        seagreen: number[];
        seashell: number[];
        sienna: number[];
        skyblue: number[];
        slateblue: number[];
        slategray: number[];
        slategrey: number[];
        snow: number[];
        springgreen: number[];
        steelblue: number[];
        tan: number[];
        thistle: number[];
        tomato: number[];
        turquoise: number[];
        violet: number[];
        wheat: number[];
        whitesmoke: number[];
        yellowgreen: number[];
    };
    hexToRgb: (notation: string) => any[];
    hslToRgb: (...values: (number | any[])[]) => any[];
    hsvToRgb: (...values: (number | any[])[]) => any[];
    hueToColorComponent: (p: number, q: number, t: number) => number;
    rgbToHex: (...values: (number | any[])[]) => string;
    rgbToHsl: (...values: (number | any[])[]) => any[];
    rgbToHsv: (...values: (number | any[])[]) => any[];
};
export const curves: {
    bezier: {
        create: (points: any[]) => import("./curves/bezier/create").bezier;
        valueAt: (t: number, bezier: any) => number | any[];
        tangentAt: (t: number, bezier: any) => number | any[];
    };
};
export const geometries: {
    geom2: {
        clone: (geometry: any) => any;
        create: (sides?: any[]) => import("./geometries/geom2/create").geom2;
        fromPoints: (points: any[]) => any;
        fromCompactBinary: (data: any[]) => any;
        isA: (object: any) => boolean;
        reverse: (geometry: any) => any;
        toOutlines: (geometry: any) => any[];
        toPoints: (geometry: any) => any[];
        toSides: (geometry: any) => any[];
        toString: (geometry: any) => string;
        toCompactBinary: (geom: any) => any;
        transform: (matrix: any, geometry: any) => any;
    };
    geom3: {
        clone: (geometry: any) => any;
        create: (polygons: any) => import("./geometries/geom3/create").geom3;
        fromPoints: (listofpoints: any[]) => any;
        fromCompactBinary: (data: any) => any;
        invert: (geometry: any) => any;
        isA: (object: any) => boolean;
        toPoints: (geometry: any) => any[];
        toPolygons: (geometry: any) => any[];
        toString: (geometry: any) => string;
        toCompactBinary: (geom: any) => any;
        transform: (matrix: any, geometry: any) => any;
    };
    path2: {
        appendArc: (options: {
            endpoint: any;
            radius?: any;
            xaxisrotation?: number;
            clockwise?: boolean;
            large?: boolean;
            segments?: number;
        }, geometry: any) => any;
        appendBezier: (options: {
            controlPoints: any[];
            segment?: number;
        }, geometry: any) => any;
        appendPoints: (points: any[], geometry: any) => any;
        clone: (geometry: any) => any;
        close: (geometry: any) => any;
        concat: (...paths: any[]) => any;
        create: (points: any) => import("./geometries/path2/create").path2;
        eachPoint: (options: any, thunk: Function, path: any) => void;
        equals: (a: any, b: any) => boolean;
        fromPoints: (options: {
            closed?: boolean;
        }, points: any[]) => any;
        fromCompactBinary: (data: any) => any;
        isA: (object: any) => boolean;
        reverse: (path: any) => any;
        toPoints: (geometry: any) => any[];
        toString: (geometry: any) => string;
        toCompactBinary: (geom: any) => any;
        transform: (matrix: any, geometry: any) => any;
    };
    poly2: {
        arePointsInside: (points: any[], polygon: any) => any;
        create: (vertices?: any[]) => import("./geometries/poly2/create").poly2;
        flip: (polygon: any) => any;
        measureArea: (polygon: any) => number;
    };
    poly3: {
        clone: (...params: any[]) => any;
        create: (vertices?: any[]) => import("./geometries/poly3/create").poly3;
        fromPoints: (points: any[]) => any;
        fromPointsAndPlane: (vertices: any[], plane: any) => any;
        invert: (polygon: any) => any;
        isA: (object: any) => boolean;
        isConvex: (poly3: any) => boolean;
        measureArea: (poly3: any) => number;
        measureBoundingBox: (poly3: any) => any[];
        measureBoundingSphere: (poly3: any) => any[];
        measureSignedVolume: (poly3: any) => number;
        plane: (polygon: any) => any;
        toPoints: (geometry: any) => any[];
        toString: (poly3: any) => string;
        transform: (matrix: any, poly3: any) => any;
    };
};
export const maths: {
    constants: {
        EPS: number;
        spatialResolution: number;
    };
    line2: {
        clone: (...params: any[]) => any;
        closestPoint: (point: any, line: any) => any;
        create: () => any[];
        direction: (line: any) => any;
        distanceToPoint: (point: any, line: any) => number;
        equals: (line1: any, line2: any) => boolean;
        fromPoints: (p1: any, p2: any) => any;
        fromValues: (x: number, y: number, w: any) => any;
        intersectPointOfLines: (line1: any, line2: any) => any;
        origin: (line: any) => any;
        reverse: (...params: any[]) => any;
        toString: (line: any) => string;
        transform: (...params: any[]) => any;
        xAtY: (y: number, line: any) => number;
    };
    line3: {
        clone: (...params: any[]) => any;
        closestPoint: (point: any, line: any) => any;
        create: () => any[];
        direction: (line: any) => any;
        distanceToPoint: (point: any, line: any) => number;
        equals: (line1: any, line2: any) => boolean;
        fromPlanes: (plane1: any, plane2: any) => any;
        fromPointAndDirection: (point: any, direction: any) => any;
        fromPoints: (p1: any, p2: any) => any;
        intersectPointOfLineAndPlane: (plane: any, line: any) => any;
        origin: (line: any) => any;
        reverse: (...params: any[]) => any;
        toString: (line: any) => string;
        transform: (...params: any[]) => any;
    };
    mat4: {
        add: (...params: any[]) => any;
        clone: (...params: any[]) => any;
        create: () => any[];
        equals: (a: any, b: any) => boolean;
        fromRotation: (...params: any[]) => any;
        fromScaling: (...params: any[]) => any;
        fromTaitBryanRotation: (yaw: number, pitch: number, roll: number) => any;
        fromTranslation: (...params: any[]) => any;
        fromValues: (m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number) => any;
        fromXRotation: (...params: any[]) => any;
        fromYRotation: (...params: any[]) => any;
        fromZRotation: (...params: any[]) => any;
        identity: (...params: any[]) => any;
        isMirroring: (mat: any) => boolean;
        mirrorByPlane: (...params: any[]) => any;
        multiply: (...params: any[]) => any;
        rotate: (...params: any[]) => any;
        rotateX: (...params: any[]) => any;
        rotateY: (...params: any[]) => any;
        rotateZ: (...params: any[]) => any;
        scale: (...params: any[]) => any;
        subtract: (...params: any[]) => any;
        toString: (mat: any) => string;
        translate: (...params: any[]) => any;
    };
    plane: {
        clone: (...params: any[]) => any;
        create: () => any[];
        equals: (a: any, b: any) => boolean;
        flip: (...params: any[]) => any;
        fromNormalAndPoint: (normal: any, point: any) => any[];
        fromValues: (x: number, y: number, z: number, w: number) => any;
        fromPoints: (a: any, b: any, c: any) => any;
        fromPointsRandom: (a: any, b: any, c: any) => any;
        signedDistanceToPoint: (plane: any, vector: any) => number;
        toString: (vec: any) => string;
        transform: (matrix: any, plane: any) => any[];
    };
    utils: {
        area: (points: any) => number;
        clamp: (value: any, min: any, max: any) => number;
        interpolateBetween2DPointsForY: (point1: any, point2: any, y: any) => any[];
        intersect: (p1: any, p2: any, p3: any, p4: any) => any[];
        solve2Linear: (a: any, b: any, c: any, d: any, u: any, v: any) => number[];
    };
    vec2: {
        abs: (...params: any[]) => any;
        add: (...params: any[]) => any;
        angle: (vector: any) => number;
        angleDegrees: (vector: any) => number;
        angleRadians: (vector: any) => number;
        canonicalize: (vector: any) => any;
        clone: (...params: any[]) => any;
        create: () => any[];
        cross: (...params: any[]) => any;
        distance: (a: any, b: any) => number;
        divide: (...params: any[]) => any;
        dot: (a: any, b: any) => number;
        equals: (a: any, b: any) => boolean;
        fromAngle: (radians: any) => any;
        fromAngleDegrees: (degrees: any) => any;
        fromAngleRadians: (radians: any) => any;
        fromArray: (data: any[]) => any;
        fromScalar: (scalar: number) => any;
        fromValues: (x: number, y: number) => any;
        length: (a: any) => number;
        lerp: (...params: any[]) => any;
        max: (...params: any[]) => any;
        min: (...params: any[]) => any;
        multiply: (...params: any[]) => any;
        negate: (...params: any[]) => any;
        normal: (...params: any[]) => any;
        normalize: (...params: any[]) => any;
        rotate: (...params: any[]) => any;
        scale: (...params: any[]) => any;
        squaredDistance: (a: any, b: any) => number;
        squaredLength: (a: any) => number;
        subtract: (...params: any[]) => any;
        toString: (vec: any) => string;
        transform: (...params: any[]) => any;
    };
    vec3: {
        abs: (...params: any[]) => any;
        add: (...params: any[]) => any;
        angle: (a: any, b: any) => number;
        canonicalize: (vector: any) => any;
        clone: (...params: any[]) => any;
        create: () => any[];
        cross: (...params: any[]) => any;
        distance: (a: any, b: any) => number;
        divide: (...params: any[]) => any;
        dot: (a: any, b: any) => number;
        equals: (a: any, b: any) => boolean;
        fromArray: (data: any[]) => any;
        fromScalar: (scalar: any) => any;
        fromValues: (x: number, y: number, z: number) => any;
        fromVec2: (vec2: any, z?: number) => any;
        length: (a: any) => number;
        lerp: (...params: any[]) => any;
        max: (...params: any[]) => any;
        min: (...params: any[]) => any;
        multiply: (...params: any[]) => any;
        negate: (...params: any[]) => any;
        normalize: (...params: any[]) => any;
        orthogonal: (...params: any[]) => any;
        rotateX: (...params: any[]) => any;
        rotateY: (...params: any[]) => any;
        rotateZ: (...params: any[]) => any;
        scale: (...params: any[]) => any;
        squaredDistance: (a: any, b: any) => number;
        squaredLength: (a: any) => number;
        subtract: (...params: any[]) => any;
        toString: (vec: any) => string;
        transform: (...params: any[]) => any;
        unit: (...params: any[]) => any;
    };
    vec4: {
        clone: (...params: any[]) => any;
        create: () => any[];
        dot: (a: any, b: any) => number;
        fromScalar: (scalar: number) => any;
        fromValues: (x: number, y: number, z: number, w: number) => any;
        toString: (vec: any) => string;
        transform: (...params: any[]) => any;
    };
};
export const measurements: {
    measureAggregateArea: (...geometries: any[]) => number;
    measureAggregateBoundingBox: (...geometries: any[]) => any[];
    measureAggregateEpsilon: (...geometries: any[]) => number;
    measureAggregateVolume: (...geometries: any[]) => number;
    measureArea: (...geometries: any[]) => number | any[];
    measureBoundingBox: (...geometries: any[]) => any[];
    measureEpsilon: (...geometries: any[]) => number | any[];
    measureVolume: (...geometries: any[]) => number | any[];
};
export const primitives: {
    arc: (options?: {
        center?: any[];
        radius?: number;
        startAngle?: number;
        endAngle?: number;
        segments?: number;
        makeTangent?: boolean;
    }) => any;
    circle: (options?: {
        center?: any[];
        radius?: number;
        startAngle?: number;
        endAngle?: number;
        segments?: number;
    }) => any;
    cube: (options?: {
        center?: any[];
        size?: number;
    }) => any;
    cuboid: (options?: {
        center?: any[];
        size?: any[];
    }) => any;
    cylinder: (options?: {
        center?: any[];
        height?: any[];
        radius?: number;
        segments?: number;
    }) => any;
    cylinderElliptic: (options?: {
        center?: any[];
        height?: any;
        startRadius?: any;
        startAngle?: number;
        endRadius?: any;
        endAngle?: number;
        segments?: number;
    }) => any;
    ellipse: (options?: {
        center?: any[];
        radius?: any[];
        startAngle?: number;
        endAngle?: number;
        segments?: number;
    }) => any;
    ellipsoid: (options?: {
        center?: any[];
        radius?: any[];
        segments?: number;
        axes?: any[];
    }) => any;
    geodesicSphere: (options?: {
        radius?: number;
        frequency?: number;
    }) => any;
    line: (points: any[]) => any;
    polygon: (options: {
        points: any[];
        paths?: any[];
    }) => any;
    polyhedron: (options: {
        points: any[];
        faces: any[];
        colors?: any[];
        orientation?: any[];
    }) => any;
    rectangle: (options?: {
        center?: any[];
        size?: any[];
    }) => any;
    roundedCuboid: (options?: {
        center?: any[];
        size?: any[];
        roundRadius?: number;
        segments?: number;
    }) => any;
    roundedCylinder: (options?: {
        center?: any[];
        height?: any[];
        radius?: number;
        roundRadius?: number;
        segments?: number;
    }) => any;
    roundedRectangle: (options?: {
        center?: any[];
        size?: any[];
        roundRadius?: number;
        segments?: number;
    }) => any;
    sphere: (options?: {
        center?: any[];
        radius?: number;
        segments?: number;
        axes?: any[];
    }) => any;
    square: (options?: {
        center?: any[];
        size?: number;
    }) => any;
    star: (options?: {
        center?: any[];
        vertices?: number;
        density?: number;
        outerRadius?: number;
        innerRadius?: number;
        startAngle?: number;
    }) => any;
    torus: (options?: {
        innerRadius?: number;
        outerRadius?: number;
        innerSegments?: any;
        outerSegments?: any;
        innerRotation?: any;
        outerRotation?: number;
        startAngle?: number;
    }) => any;
};
export const text: {
    vectorChar: (options?: any, char?: string) => import("./text/vectorChar").VectorCharObject;
    vectorText: (options?: any, text?: string) => any[];
};
export const utils: {
    areAllShapesTheSameType: (shapes: any[]) => boolean;
    degToRad: (degrees: number) => number;
    flatten: (arr: any[]) => any[];
    fnNumberSort: (a: any, b: any) => number;
    insertSorted: (array: any, element: any, comparefunc: any) => void;
    radiusToSegments: (radius: number, minimumLength: number, minimumAngle: number) => number;
    radToDeg: (radians: number) => number;
};
export const booleans: {
    intersect: (...geometries: any[]) => any;
    subtract: (...geometries: any[]) => any;
    union: (...geometries: any[]) => any;
};
export const expansions: {
    expand: (options: {
        delta?: number;
        corners?: string;
        segments?: any;
    }, ...objects: any[]) => any;
    offset: (options: {
        delta?: any;
        corners?: string;
        segments?: any;
    }, ...objects: any[]) => any;
};
export const extrusions: {
    extrudeFromSlices: (options: {
        numberOfSlices?: any;
        isCapped?: boolean;
        callback?: Function;
    }, base: any) => any;
    extrudeLinear: (options: {
        height?: any[];
        twistAngle?: number;
        twistSteps?: any;
    }, ...objects: any[]) => any;
    extrudeRectangular: (options: {
        size?: number;
        height?: number;
    }, ...objects: any[]) => any;
    extrudeRotate: (options: {
        angle?: number;
        startAngle?: number;
        overflow?: string;
        segments?: number;
    }, geometry: any) => any;
    slice: {
        calculatePlane: (slice: any) => any;
        clone: (...params: any[]) => any;
        create: (edges: any) => import("./operations/extrusions/slice/create").slice;
        equals: (a: any, b: any) => boolean;
        fromPoints: (points: any[]) => any;
        fromSides: (sides: any[]) => any;
        isA: (object: any) => boolean;
        reverse: (...params: any[]) => any;
        toEdges: (slice: any) => any[];
        toPolygons: (slice: any) => any[];
        toString: (slice: any) => string;
        transform: (matrix: any, slice: any) => any;
    };
};
export const hulls: {
    hull: (...geometries: any[]) => any;
    hullChain: (...geometries: any[]) => any;
};
export const transforms: {
    align: (options: {
        modes?: any[];
        alignTo?: any[];
        grouped?: any[];
    }, ...geometries: any[]) => any;
    center: (options: {
        axes?: any[];
        center?: any[];
    }, ...geometries: any[]) => any;
    centerX: (...objects: any[]) => any;
    centerY: (...objects: any[]) => any;
    centerZ: (...objects: any[]) => any;
    mirror: (options: {
        origin?: any[];
        normal?: any[];
    }, ...objects: any[]) => any;
    mirrorX: (...objects: any[]) => any;
    mirrorY: (...objects: any[]) => any;
    mirrorZ: (...objects: any[]) => any;
    rotate: (angles: any[], ...objects: any[]) => any;
    rotateX: (angle: number, ...objects: any[]) => any;
    rotateY: (angle: number, ...objects: any[]) => any;
    rotateZ: (angle: number, ...objects: any[]) => any;
    scale: (factors: any[], ...objects: any[]) => any;
    scaleX: (offset: any, ...objects: any[]) => any;
    scaleY: (offset: any, ...objects: any[]) => any;
    scaleZ: (offset: any, ...objects: any[]) => any;
    transform: (matrix: any, ...objects: any[]) => any;
    translate: (offset: any[], ...objects: any[]) => any;
    translateX: (offset: number, ...objects: any[]) => any;
    translateY: (offset: number, ...objects: any[]) => any;
    translateZ: (offset: number, ...objects: any[]) => any;
};
